
#include <iostream>
#include <fstream>
#include <sstream>
#include <string>
#include <deque>

//using namespace std;

/** Trade Struct. Consider Example:
    Field	Value	Meaning
1. Trade ID	4926538690	Unique trade identifier
2. Price	105573.74000000	Price at which the trade happened
3. Quantity	0.00004000	Amount of asset traded
4. Quote quantity	4.22294960	Price × quantity (in quote asset, e.g., USDT)
5. Timestamp	1747699202961008	Time in microseconds or nanoseconds
6. Is Buyer Market Maker	False	True if the buyer is the market maker
7. Is Best Match	True	Whether this trade is the best match (used by Binance)
 */

struct Trade {
    long long tradeID;
    double price;
    double quantity;
    double quoteQuantity;
    long long timestamp;
    bool isBuyerMaker;
    bool isBestMatch;
};

int main() {

    // Reading the CSV File
    std::ifstream file("BTCUSDT-trades-2025-05-20.csv");
    std::string line, value;
    std::deque<Trade> ma50; // Moving Average 50.

    // Returns the first 100 values from our csv file.
    for (int i = 0; i<2;i++){
        std::getline(file, line);
        std::stringstream s (line);
        
        Trade t;
        std::getline(s, value, ',');
        t.tradeID = std::stoll(value);

        std::getline(s, value, ',');
        t.price = std::stod(value);

        std::getline(s, value, ',');
        t.quantity = std::stod(value);

        std::getline(s, value, ',');
        t.quoteQuantity = std::stod(value);

        std::getline(s, value, ',');
        t.timestamp = std::stoll(value);

        std::getline(s, value, ',');
        if (value == "True"){
            t.isBuyerMaker = true;
        }
        else{
            t.isBuyerMaker = false;
        }
        

        std::getline(s, value, ',');
        if (value == "True"){
            t.isBestMatch = true;
        }
        else{
            t.isBestMatch = false;
        }

        ma50.push_back(t);



        while (std::getline(s, value, ',')) {
            std::cout << value << " ";
        }
        


        std::cout << std::endl;
    }

    for (Trade n : ma50) {
        std::cout << "Trade ID: " << n.tradeID
                << ", Price: " << n.price
                << ", Quantity: " << n.quantity
                << ", Quote Quantity: " << n.quoteQuantity
                << ", Timestamp: " << n.timestamp
                << ", Buyer Maker: " << (n.isBuyerMaker ? "True" : "False")
                << ", Best Match: " << (n.isBestMatch ? "True" : "False")
                << std::endl;
    }
    

    return 0;
}





//// Step 2: Get Market Data --- 
// Option A (easier): Download historical price data (CSV)
// Option B (harder): Connect to Binance WebSocket API (live crypto prices)

// ✅ Goal: Print price data to console, one tick at a time

//// Step 3: Build a Basic Strategy
// Use a simple moving average crossover:

// If short MA > long MA → BUY

// If short MA < long MA → SELL
// ✅ Goal: Print "BUY"/"SELL" decisions based on price updates

// Step 4: Create a Matching Engine
// Implement a limit order book

// Match orders when buy price ≥ sell price

// Track positions and trade fills

// ✅ Goal: Execute trades generated by your strategy against your engine

// Step 5: Track PnL (Profit and Loss)
// Track open position, entry price, realized PnL

// Print live performance updates

// ✅ Goal: Know if your strategy is making or losing money

// Step 6: Log and Visualize
// Write trades to a CSV file

// Plot trades and PnL in Python (matplotlib or pandas)

// ✅ Goal: Review strategy performance visually

// Step 7 (Optional): Add Multithreading
// One thread for data feed

// One thread for strategy logic

// One thread for order matching

// ✅ Goal: Simulate real-time speed and architecture
